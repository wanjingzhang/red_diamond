# 变量、作用域与内存

1. 原始值和引用值
    1. 按值引用-简单类型    
    2. 按地址引用-复杂数据类型
    3. typeof 确定对象的类型
    4. instanceof 检测引用值 由原型链决定

2. 执行上下文和作用域
    1. 上下文
        1. 变量和函数的上下文决定了他们可以访问哪些数据，以及他们的行为
        2. 每个上下文都有一个关联的*变量对象*，这个上下文中定义的所有变量和函数都存在于这个对象上
        3. 虽然无法从代码访问，但后台处理数据会用到它
        4. 全局上下文是最外层的上下文，浏览器 window，Node Global
        5. 上下文的作用域（全局，函数，块级）
        6. 上下文确定何时释放内存
    2. 作用域
        * 1. 当代码*执行流*进入函数时，函数上下文被*推到*一个上下文栈
        2. 当函数执行完成，上下文栈就会*弹出*该函数的上下文，将控制权返还给之前的上下文。
        3. 在上下文代码执行的时候，会创建变量对象的*作用域链*，它决定了上下文代码在访问变量和函数时的顺序。
        4. 代码正在执行的上下文变量对象，始终位于作用域链的最前端
        5. 作用域链的下一个对象，来自包涵上下文，再下一个对象来自再下一个包涵上下文，以此类推直至全局上下文

3. 作用域链增强
    1. 某些语句会导致在作用域链的前端临时添加一个上下文，这个上下文在代码执行后被删除try catch语句的catch块，with语句
    2. 用const声明的对象属性如何限制修改？ `Object.freeze(obj)`再对属性赋值时不会报错，但是会*静默失败*
    3. 标识符查找：从作用域链前端开始，以给定的名称搜索对应的标识符。如果在局部上下文找到 则搜索停止 变量确定，如果没有找到变量 则沿作用域链继续搜索 直到全局上下文的变量对象。如果仍没有找到 则说明其未声明。

4. 垃圾回收
    1. 是周期性的，每隔一定时间就会自动运行
    2. 函数中局部变量会在函数执行时存在，栈内存会分配变量空间 已保存响应的值
    3. 如何标记变量以便回收呢？标记清理、引用计数
    4. 标记清理
        1. 最常用，在上下文中的变量永远都不会被清理，如果变量离开了上下文，它会被加上离开上下文的标记。加标记(反转某一位，在上下文列表和不在上下文列表)的实现不重要，重要的是策略。
        2. 当垃圾回收程序运行的时候，会把内存中所有下文和上下文中引用变量的标记去掉，在此之后被加上标记的变量就是待删除的变量。随后在垃圾回收程序做内存清理，销毁带标记的所有值，并回收他们的内存。
        3. IE,Firefox,Opera,Chrome,Safari都实现了标记清理，只在运行回收的频率上有所差异
    5. 引用计数
        1. 记录变量被引用了多少次，0次使用就会被回收
        2. 不常用，某些IE旧版本用。它有严重的问题：循环引用
        3. 循环引用：对象A有一个指针指向对象B，对象B也引用了对象A 会导致大量内存永远不会被释放
        4. 确保在不使用的情况下切断原生JS对象与DOM元素之间的连接
    6. 性能 
        1. 垃圾回收的时间调度很重要，尤其在内存有限的移动设备上，垃圾回收有可能会明显拖慢渲染和帧速率
        2. 要确保垃圾回收的运行时间，快速完成
        3. 垃圾回收不可以过于频繁的运行，它会对性能产生严重影响
        4. 内存管理：优化内存占用的最佳手段就是保证在执行代码时，只保存必要的数据。如果数据不再必要，那么把它设置为null，从而释放其引用，这叫*解除引用*。
        5. 解除应用并不会立即导致相关的内存被回收，关键在于确保相关的值不在上下文中，因此在下次垃圾回收时会被回收。
5. 提升性能
    1. 通过const和let声明改善代码风格，更有助于改善垃圾回收的过程，他们可以让垃圾回收程序更早的介入，尽早回收内存
    2. 隐藏类&删除类
        1. 隐藏类 class Article(){};let a1 = new Article();a1.author='Jake';
        要避免先创建再动态补充，在构造函数中一次声明所有的属性 class Article(author){this.author=author;
        2. 删除类 class Article(author){this.author = author;};let a1 = new Article();delete a1author;
        delete 会导致相同的隐藏片段，最佳实践时把不想要的属性设置为null。 a1.author=null
    3. 内存泄漏
        1. 没有用任何关键字声明的变量 fn(){name="a"},解释器会把name当成window上创建的属性，只要window本身不被清理就不会消失。
        2. 定时器的回调通过闭包引入外部变量 let name = 'Jake';setInterval(()=>{return function(){return name;}});定时器只要一直运行，回调函数中引用的name就会一直占用内存，因而外部变量就不会清理
        3. 函数闭包只要返回的函数存在就不能清理name，假如name的内容很大，就有可能是个大问题
    4. 静态分配与对象池
        1. 对象的*更替速度*是决定何时进行垃圾回收的一个标准，如果很多对象同时被初始化，又超出了作用域。那么浏览器就会用更加激进的方式调用垃圾回收程序。解决方法就是修改已有的对象，不要动态创建矢量对象。
        2. 在初始化的时候创建一个对象池，用来管理一组可回收的对象。应用程序可以向对象池请求一个对象，设置其属性使用他，在操作完成后还给对象池，由于没发生变化，垃圾回收探测就不会发现有对象更替。在初始化数组时就设置数组的大小，不要动态修改数组大小，比如 ary.push()



